// 水面 ResultRT から簡易反射コースティクス用のヒット情報を生成
// 入力: ResultRT (RGB=ワールド法線 非パック), Source/Target Transform, Directional Light
// 出力: _HitBuffer (xy=targetUV, z=intensity, w=validFlag)

#pragma kernel GenerateHits

#define THREADS 8

SamplerState samplerLinearClamp
{
    Filter = MIN_MAG_MIP_LINEAR;
    AddressU = Clamp;
    AddressV = Clamp;
};

Texture2D<float4> _ResultTex;
RWStructuredBuffer<float4> _HitBuffer;

cbuffer CausticsParams
{
    int2 _SourceResolution;
    float _EnergyScale;
    float _NormalInfluence;

    float3 _LightDirWS;
    float3 _SourcePos;
    float3 _SourceRight;   // unit
    float3 _SourceUp;      // unit
    float2 _SourceScale;   // quad scale (x,y)

    float3 _TargetPos;
    float3 _TargetRight;   // unit
    float3 _TargetUp;      // unit
    float3 _TargetNormal;  // unit
    float2 _TargetScale;   // quad scale (x,y)
}

[numthreads(THREADS, THREADS, 1)]
void GenerateHits(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _SourceResolution.x || id.y >= _SourceResolution.y) return;
    uint index = id.y * _SourceResolution.x + id.x;

    float2 uv = (float2(id.xy) + 0.5) / float2(_SourceResolution);
    float3 nWorld = _ResultTex.SampleLevel(samplerLinearClamp, uv, 0).xyz;
    nWorld = normalize(lerp(float3(0, 1, 0), nWorld, saturate(_NormalInfluence)));

    // 水面上のワールド座標（QuadローカルXY: -0.5..0.5）
    float2 local = (uv - 0.5) * _SourceScale;
    float3 worldPos = _SourcePos + _SourceRight * local.x + _SourceUp * local.y;

    float3 L = normalize(_LightDirWS);     // 光線方向（ライトから物体へ）
    float3 I = -L;                         // 入射
    float3 R = reflect(I, nWorld);         // 反射方向

    float denom = dot(R, _TargetNormal);
    if (abs(denom) < 1e-5)
    {
        _HitBuffer[index] = 0;
        return;
    }

    float t = dot(_TargetPos - worldPos, _TargetNormal) / denom;
    if (t <= 0)
    {
        _HitBuffer[index] = 0;
        return;
    }

    float3 hitPos = worldPos + R * t;
    float3 rel = hitPos - _TargetPos;
    float localX = dot(rel, _TargetRight);
    float localY = dot(rel, _TargetUp);
    float halfX = _TargetScale.x * 0.5;
    float halfY = _TargetScale.y * 0.5;
    if (abs(localX) > halfX || abs(localY) > halfY)
    {
        _HitBuffer[index] = 0;
        return;
    }
    float2 uvTarget = float2(localX / _TargetScale.x + 0.5, localY / _TargetScale.y + 0.5);

    float nl = saturate(dot(nWorld, -L));
    float intensity = nl * _EnergyScale;

    _HitBuffer[index] = float4(uvTarget, intensity, 1.0);
}
