// Caustics photon splat: source RT の法線から反射/屈折方向を計算し、受光平面上の密度を積算する

#pragma kernel Clear
#pragma kernel Accumulate

#define THREAD_CLEAR 256
#define THREAD_ACCUM 8

RWStructuredBuffer<uint> _Density; // fixed-point (scaled by _DensityScale)

Texture2D<float4> _ResultTex;      // RGB: normal encoded 0..1
SamplerState samplerLinearClamp
{
    Filter = MIN_MAG_MIP_LINEAR;
    AddressU = Clamp;
    AddressV = Clamp;
};

cbuffer Params
{
    int2  _SourceResolution;
    int2  _TargetResolution;
    uint  _TotalCount;
    float _DensityScale;      // 例: 4096
    float _EnergyScale;       // 例: 1.0
    float _NormalInfluence;   // 0..1
    float _Eta;               // n1/n2 for refraction
    uint  _LightType;         // 0: Directional, 1: Point/Spot
    uint  _CausticsType;      // 0: Reflection, 1: Refraction

    float3 _LightProp;        // dir (Directional) or position (Point)

    float3 _SourcePos;
    float3 _SourceRight;      // unit
    float3 _SourceUp;         // unit
    float3 _SourceNormal;     // unit
    float2 _SourceScale;      // size (x,y)

    float3 _TargetPos;
    float3 _TargetRight;      // unit
    float3 _TargetUp;         // unit
    float3 _TargetNormal;     // unit
    float2 _TargetScale;      // size (x,y)
}

float3 DecodeNormal(float3 enc)
{
    return normalize(enc * 2.0 - 1.0);
}

[numthreads(THREAD_CLEAR, 1, 1)]
void Clear(uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx < _TotalCount)
    {
        _Density[idx] = 0;
    }
}

[numthreads(THREAD_ACCUM, THREAD_ACCUM, 1)]
void Accumulate(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _SourceResolution.x || id.y >= _SourceResolution.y) return;

    float2 uv = (float2(id.xy) + 0.5) / float2(_SourceResolution);
    float3 nTex = DecodeNormal(_ResultTex.SampleLevel(samplerLinearClamp, uv, 0).xyz);

    // ワールド法線（平面法線とのブレンドで影響度を調整）
    float3 nWorld = normalize(nTex.x * _SourceRight + nTex.y * _SourceUp + nTex.z * _SourceNormal);
    nWorld = normalize(lerp(_SourceNormal, nWorld, saturate(_NormalInfluence)));

    // 水面上のワールド座標
    float2 local = (uv - 0.5) * _SourceScale;
    float3 worldPos = _SourcePos + _SourceRight * local.x + _SourceUp * local.y;

    float3 L;
    if (_LightType == 0)
    {
        L = normalize(_LightProp); // 光線進行方向
    }
    else
    {
        L = normalize(worldPos - _LightProp); // lightPos -> surface
    }

    float3 I = -L; // 入射
    float3 dir;

    if (_CausticsType == 0)
    {
        dir = reflect(I, nWorld);
    }
    else
    {
        dir = refract(I, nWorld, _Eta);
        if (dot(dir, dir) < 1e-6)
        {
            dir = reflect(I, nWorld); // 全反射フォールバック
        }
    }
    dir = normalize(dir);

    float denom = dot(dir, _TargetNormal);
    if (abs(denom) < 1e-6) return;
    float t = dot(_TargetPos - worldPos, _TargetNormal) / denom;
    if (t <= 0) return;

    float3 hitPos = worldPos + dir * t;
    float3 rel = hitPos - _TargetPos;
    float localX = dot(rel, _TargetRight);
    float localY = dot(rel, _TargetUp);
    float halfX = _TargetScale.x * 0.5;
    float halfY = _TargetScale.y * 0.5;
    if (abs(localX) > halfX || abs(localY) > halfY) return;

    float2 uvTarget = float2(localX / _TargetScale.x + 0.5, localY / _TargetScale.y + 0.5);

    uint2 pixel = (uint2)clamp(uvTarget * (float2)_TargetResolution, 0.0, (float2)_TargetResolution - 1.0);
    uint idx = pixel.y * _TargetResolution.x + pixel.x;

    float nl = saturate(dot(nWorld, -I));
    uint add = (uint)max(0.0, round(nl * _EnergyScale * _DensityScale));
    InterlockedAdd(_Density[idx], add);
}
