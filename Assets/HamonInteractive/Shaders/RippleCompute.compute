// 波紋シミュレーション用 Compute Shader
// 状態: R=高さ, G=速度
// 出力: RGB=法線(0-1), A=高さ

#pragma kernel SimStep
#pragma kernel MakeNormals
#pragma kernel Brush
#pragma kernel ClearForce

#define THREADS 8

SamplerState samplerLinearClamp
{
    Filter = MIN_MAG_MIP_LINEAR;
    AddressU = Clamp;
    AddressV = Clamp;
};

SamplerState samplerPointClamp
{
    Filter = MIN_MAG_MIP_POINT;
    AddressU = Clamp;
    AddressV = Clamp;
};

Texture2D<float2> _StateRead;
RWTexture2D<float2> _StateWrite;

Texture2D<float> _Boundary;
Texture2D<float> _DepthTex;
Texture2D<float2> _FlowTex;
Texture2D<float> _ForceTex;
Texture2D<float> _ExternalForceTex;

RWTexture2D<float> _ForceTarget;       // Brush/Clear 用
RWTexture2D<float4> _Result;           // RGB: normal, A: height

cbuffer RippleParams
{
    float _DeltaTime;
    float _Damping;
    float _AmplitudeDecay;
    float _WaveSpeed;
    float _DepthScale;
    float _FlowScale;
    float _BoundaryBounce;
    float _ForceToVelocity;
    float2 _InvSimSize;
    int2 _SimSize;
    int _UseBoundary;
    int _UseDepth;
    int _UseFlow;
    int _UseExternalForce;
}

// Brush params
float4 _Brush;       // xy=center(uv), z=radius, w=strength
float _BrushFalloff; // 1=線形, 2=二乗 など

float sampleBoundary(int2 coord)
{
    if (_UseBoundary == 0) return 1.0;
    coord = clamp(coord, int2(0, 0), _SimSize - 1);
    return _Boundary.Load(int3(coord, 0)).r;
}

float sampleDepth(float2 uv)
{
    if (_UseDepth == 0) return 0.0;
    return _DepthTex.SampleLevel(samplerLinearClamp, uv, 0).r;
}

float2 sampleStateAdvected(float2 uv)
{
    return _StateRead.SampleLevel(samplerLinearClamp, uv, 0);
}

float sampleForce(float2 uv)
{
    float f = _ForceTex.SampleLevel(samplerLinearClamp, uv, 0).r;
    if (_UseExternalForce != 0)
    {
        f += _ExternalForceTex.SampleLevel(samplerLinearClamp, uv, 0).r;
    }
    return f;
}

float fetchHeightOffset(float2 backUV, float2 currUV, int2 offset, float hCenter)
{
    float2 uvOffset = saturate(backUV + float2(offset) * _InvSimSize);
    float h = _StateRead.SampleLevel(samplerLinearClamp, uvOffset, 0).x;

    if (_UseBoundary != 0)
    {
        float2 boundaryUV = saturate(currUV + float2(offset) * _InvSimSize);
        float b = _Boundary.SampleLevel(samplerPointClamp, boundaryUV, 0).r;
        if (b < 0.5)
        {
            h = hCenter * _BoundaryBounce;
        }
    }
    return h;
}

[numthreads(THREADS, THREADS, 1)]
void SimStep(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _SimSize.x || id.y >= _SimSize.y) return;

    int2 coord = int2(id.xy);
    float2 uv = (coord + 0.5) * _InvSimSize;

    float boundary = sampleBoundary(coord);
    if (boundary < 0.5)
    {
        float v = _StateRead.Load(int3(coord, 0)).y;
        _StateWrite[coord] = float2(0, -v * _BoundaryBounce);
        return;
    }

    float2 flow = (_UseFlow != 0) ? _FlowTex.SampleLevel(samplerLinearClamp, uv, 0).xy * _FlowScale : 0;
    float2 backUV = saturate(uv - flow * _DeltaTime);

    float2 state = sampleStateAdvected(backUV);
    float h = state.x;
    float v = state.y;

    float force = sampleForce(uv) * _ForceToVelocity;
    float depth = sampleDepth(uv);
    float c = _WaveSpeed * (1 + depth * _DepthScale);

    float hL = fetchHeightOffset(backUV, uv, int2(-1, 0), h);
    float hR = fetchHeightOffset(backUV, uv, int2(1, 0), h);
    float hD = fetchHeightOffset(backUV, uv, int2(0, -1), h);
    float hU = fetchHeightOffset(backUV, uv, int2(0, 1), h);

    float lap = (hL + hR + hD + hU - 4.0 * h);

    v += (c * c * lap - _Damping * v) * _DeltaTime;
    v += force * _DeltaTime;
    h += v * _DeltaTime;

    float decay = max(1.0 - _AmplitudeDecay * _DeltaTime, 0.0);
    h *= decay;
    v *= decay;

    _StateWrite[coord] = float2(h, v);
}

[numthreads(THREADS, THREADS, 1)]
void MakeNormals(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _SimSize.x || id.y >= _SimSize.y) return;
    int2 coord = int2(id.xy);

    int2 left = int2(max(coord.x - 1, 0), coord.y);
    int2 right = int2(min(coord.x + 1, _SimSize.x - 1), coord.y);
    int2 down = int2(coord.x, max(coord.y - 1, 0));
    int2 up = int2(coord.x, min(coord.y + 1, _SimSize.y - 1));

    float hL = _StateRead.Load(int3(left, 0)).x;
    float hR = _StateRead.Load(int3(right, 0)).x;
    float hD = _StateRead.Load(int3(down, 0)).x;
    float hU = _StateRead.Load(int3(up, 0)).x;
    float hC = _StateRead.Load(int3(coord, 0)).x;

    float dhx = (hR - hL);
    float dhy = (hU - hD);

    // z を上方向にした法線（フラットで (0,0,1) -> エンコード後は青系）
    float3 n = normalize(float3(-dhx, -dhy, 1.0));
    float3 encoded = n * 0.5 + 0.5;

    _Result[coord] = float4(encoded, hC);
}

[numthreads(THREADS, THREADS, 1)]
void Brush(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _SimSize.x || id.y >= _SimSize.y) return;
    int2 coord = int2(id.xy);
    float2 uv = (coord + 0.5) * _InvSimSize;

    float dist = distance(uv, _Brush.xy);
    if (dist > _Brush.z) return;

    float t = saturate(1.0 - dist / _Brush.z);
    float fall = pow(t, max(_BrushFalloff, 0.0001));
    float add = _Brush.w * fall;

    _ForceTarget[coord] = _ForceTarget[coord] + add;
}

[numthreads(THREADS, THREADS, 1)]
void ClearForce(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _SimSize.x || id.y >= _SimSize.y) return;
    int2 coord = int2(id.xy);
    _ForceTarget[coord] = 0.0;
}
