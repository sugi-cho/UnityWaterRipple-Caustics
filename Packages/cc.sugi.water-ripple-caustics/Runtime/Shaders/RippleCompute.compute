// 波紋シミュレーション用 Compute Shader
// 状態: R=現在の高さ, G=前フレームの高さ（中央差分で時間二階微分を表現）
// 出力: RGB=ワールド法線(非パック, -1..1 を想定, Up=+Y), A=高さ

#pragma kernel SimStep
#pragma kernel MakeNormals
#pragma kernel BlurNormals
#pragma kernel Brush
#pragma kernel ClearForce

#define THREADS 8

SamplerState samplerLinearClamp
{
    Filter = MIN_MAG_MIP_LINEAR;
    AddressU = Clamp;
    AddressV = Clamp;
};

SamplerState samplerPointClamp
{
    Filter = MIN_MAG_MIP_POINT;
    AddressU = Clamp;
    AddressV = Clamp;
};

Texture2D<float2> _StateRead;
RWTexture2D<float2> _StateWrite;

Texture2D<float> _Boundary;
Texture2D<float> _DepthTex;
Texture2D<float2> _FlowTex;
Texture2D<float> _ForceTex;
Texture2D<float> _ExternalForceTex;

RWTexture2D<float> _ForceTarget;       // Brush/Clear 用
RWTexture2D<float4> _Result;           // RGB: normal, A: height
RWTexture2D<float4> _ResultTemp;       // MakeNormals 書き出し先
Texture2D<float4> _ResultSrc;          // BlurNormals 参照元

cbuffer RippleParams
{
    float _DeltaTime;
    float _Damping;
    float _AmplitudeDecay;
    float _WaveSpeed;
    float _DepthScale;
    float _FlowScale;
    float _BoundaryBounce;
    float _ForceToVelocity;
    float2 _InvSimSize;
    int2 _SimSize;
    int _UseBoundary;
    int _UseDepth;
    int _UseFlow;
    int _UseExternalForce;
    int _EdgeModeHorizontal; // 0=Bounce, 1=Absorb, 2=Wrap
    int _EdgeModeVertical;   // 0=Bounce, 1=Absorb, 2=Wrap
    float _NormalGradScale;
    int _NormalBlurRadius;   // 0-3
    float _NormalBlurSigma;  // >0
}

// Brush params
float4 _Brush;       // xy=center(uv), z=radius, w=strength
float _BrushFalloff; // 1=線形, 2=二乗 など

float sampleBoundary(int2 coord)
{
    if (_UseBoundary == 0) return 1.0;
    coord = clamp(coord, int2(0, 0), _SimSize - 1);
    return _Boundary.Load(int3(coord, 0)).r;
}

float sampleDepth(float2 uv)
{
    if (_UseDepth == 0) return 0.0;
    return _DepthTex.SampleLevel(samplerLinearClamp, uv, 0).r;
}

// エッジ処理を適用。戻り値: bounceMul (吸収時はクランプのみで減衰は後段で処理)
float processEdge(inout float2 uv)
{
    float bounceMul = 1.0;

    // X edge
    if (uv.x < 0.0 || uv.x > 1.0)
    {
        if (_EdgeModeHorizontal == 2) // Wrap
        {
            uv.x = frac(uv.x + 1.0);
        }
        else if (_EdgeModeHorizontal == 1) // Absorb
        {
            uv.x = saturate(uv.x); // 端でクランプ（減衰は後でスポンジ処理）
        }
        else // Bounce
        {
            uv.x = saturate(uv.x);
            bounceMul *= _BoundaryBounce;
        }
    }

    // Y edge
    if (uv.y < 0.0 || uv.y > 1.0)
    {
        if (_EdgeModeVertical == 2) // Wrap
        {
            uv.y = frac(uv.y + 1.0);
        }
        else if (_EdgeModeVertical == 1) // Absorb
        {
            uv.y = saturate(uv.y);
        }
        else // Bounce
        {
            uv.y = saturate(uv.y);
            bounceMul *= _BoundaryBounce;
        }
    }
    return bounceMul;
}

float2 sampleStateAdvected(float2 uv)
{
    float bounce = processEdge(uv);
    if (bounce < 0.0) return float2(0, 0); // absorb
    return _StateRead.SampleLevel(samplerLinearClamp, uv, 0) * bounce;
}

float sampleForce(float2 uv)
{
    float f = _ForceTex.SampleLevel(samplerLinearClamp, uv, 0).r;
    if (_UseExternalForce != 0)
    {
        f += _ExternalForceTex.SampleLevel(samplerLinearClamp, uv, 0).r;
    }
    return f;
}

float fetchHeightOffset(float2 backUV, float2 currUV, int2 offset, float hCenter)
{
    float2 uvOffset = backUV + float2(offset) * _InvSimSize;
    float bounceMul = processEdge(uvOffset);
    if (bounceMul < 0.0) return 0.0; // absorb

    float h = _StateRead.SampleLevel(samplerLinearClamp, uvOffset, 0).x * bounceMul;

    if (_UseBoundary != 0)
    {
        float2 boundaryUV = uvOffset; // wrap/clamp済み
        float b = _Boundary.SampleLevel(samplerPointClamp, boundaryUV, 0).r;
        if (b < 0.5)
        {
            h = hCenter * _BoundaryBounce;
        }
    }
    return h;
}

[numthreads(THREADS, THREADS, 1)]
void SimStep(uint3 id : SV_DispatchThreadID)
{
    int2 coord = int2(id.xy);
    if (coord.x >= _SimSize.x || coord.y >= _SimSize.y) return;
    float2 uv = (coord + 0.5) * _InvSimSize;

    // dt spike guard
    float dt = min(_DeltaTime, 0.05);
    float dt2 = dt * dt;

    float2 flow = (_UseFlow != 0) ? _FlowTex.SampleLevel(samplerLinearClamp, uv, 0).xy * _FlowScale : 0;
    float2 backUV = uv - flow * dt;

    float2 state = sampleStateAdvected(backUV);
    float h = state.x;      // 現在高さ
    float hPrev = state.y;  // 前フレーム高さ

    float boundary = sampleBoundary(coord);
    if (boundary < 0.5)
    {
        // 固体セルは高さをゼロにし、前フレームは反射させて残響を抑える
        _StateWrite[coord] = float2(0, -hPrev * _BoundaryBounce);
        return;
    }

    float force = sampleForce(uv);
    force = clamp(force, -50.0, 50.0);
    force *= _ForceToVelocity;
    float depth = sampleDepth(uv);
    float c = _WaveSpeed * (1 + depth * _DepthScale);
    // 安定化: CFL 条件 c*dt <= 1/sqrt(2) より余裕を持ってクランプ
    float cMax = 0.5 / max(dt, 1e-5);
    c = min(c, cMax);

    float hL = fetchHeightOffset(backUV, uv, int2(-1, 0), h);
    float hR = fetchHeightOffset(backUV, uv, int2(1, 0), h);
    float hD = fetchHeightOffset(backUV, uv, int2(0, -1), h);
    float hU = fetchHeightOffset(backUV, uv, int2(0, 1), h);

    float lap = (hL + hR + hD + hU - 4.0 * h);

    float c2dt2 = (c * c) * dt2;

    // 中央差分の波動方程式: h_{n+1} = (2 - d*dt)h_n - (1 - d*dt)h_{n-1} + c^2 dt^2 lap + F dt^2
    float dampingTerm = max(1.0 - _Damping * dt, 0.0);
    float hNext = (2.0 * h - hPrev) * dampingTerm + c2dt2 * lap + force * dt2;

    // 高周波アーチファクト抑制用の微少な数値粘性
    hNext += 0.003 * lap;

    float decay = max(1.0 - _AmplitudeDecay * dt, 0.0);
    hNext *= decay;
    h *= decay;

    // Dead zone (relaxed to let very small waves propagate)
    float vel = hNext - h;
    const float deadZone = 1e-5;
    if (abs(hNext) < deadZone && abs(vel) < deadZone)
    {
        hNext = 0;
        h = 0;
    }

    // 発散対策のハードクランプ
    hNext = clamp(hNext, -256.0, 256.0);

    // 吸収エッジ用スポンジ: 指定方向が Absorb の場合、端付近で減衰
    // 定数スポンジ幅（ピクセル）
    const float absorbWidth = 12.0;
    float fadeX = 1.0;
    float fadeY = 1.0;
    if (_EdgeModeHorizontal == 1) // Absorb
    {
        float distX = min(coord.x + 1, _SimSize.x - coord.x);
        fadeX = saturate((distX - 0.5) / absorbWidth);
    }
    if (_EdgeModeVertical == 1) // Absorb
    {
        float distY = min(coord.y + 1, _SimSize.y - coord.y);
        fadeY = saturate((distY - 0.5) / absorbWidth);
    }
    float edgeFade = min(fadeX, fadeY);
    edgeFade = edgeFade * edgeFade; // 強めに減衰
    if (edgeFade < 1e-3)
    {
        hNext = 0;
        h = 0;
    }
    else
    {
        hNext *= edgeFade;
        h *= edgeFade;
    }

    _StateWrite[coord] = float2(hNext, h);
}

[numthreads(THREADS, THREADS, 1)]
void MakeNormals(uint3 id : SV_DispatchThreadID)
{
    int2 coord = int2(id.xy);
    if (coord.x >= _SimSize.x || coord.y >= _SimSize.y) return;

    int2 left = int2(max(coord.x - 1, 0), coord.y);
    int2 right = int2(min(coord.x + 1, _SimSize.x - 1), coord.y);
    int2 down = int2(coord.x, max(coord.y - 1, 0));
    int2 up = int2(coord.x, min(coord.y + 1, _SimSize.y - 1));
    int2 upLeft = int2(left.x, up.y);
    int2 upRight = int2(right.x, up.y);
    int2 downLeft = int2(left.x, down.y);
    int2 downRight = int2(right.x, down.y);

    float hL = _StateRead.Load(int3(left, 0)).x;
    float hR = _StateRead.Load(int3(right, 0)).x;
    float hD = _StateRead.Load(int3(down, 0)).x;
    float hU = _StateRead.Load(int3(up, 0)).x;
    float hUL = _StateRead.Load(int3(upLeft, 0)).x;
    float hUR = _StateRead.Load(int3(upRight, 0)).x;
    float hDL = _StateRead.Load(int3(downLeft, 0)).x;
    float hDR = _StateRead.Load(int3(downRight, 0)).x;
    float hC = _StateRead.Load(int3(coord, 0)).x;

    // Sobel filter for smoother gradient
    float dhx = (hR * 2.0 + hUR + hDR) - (hL * 2.0 + hUL + hDL);
    float dhy = (hU * 2.0 + hUL + hUR) - (hD * 2.0 + hDL + hDR);
    float2 grad = float2(dhx, dhy) * (0.5 * _NormalGradScale);

    // Y-up を基準としたワールド法線（XZ 平面上の高さマップ想定）
    float3 n = float3(-grad.x, 1.0, -grad.y);
    float lenSq = dot(n, n);
    if (lenSq < 1e-8)
    {
        n = float3(0.0, 1.0, 0.0);
    }
    else
    {
        n = normalize(n);
    }
    // パッキングせずそのまま書き出し
    _ResultTemp[coord] = float4(n, hC);
}

[numthreads(THREADS, THREADS, 1)]
void BlurNormals(uint3 id : SV_DispatchThreadID)
{
    int2 coord = int2(id.xy);
    if (coord.x >= _SimSize.x || coord.y >= _SimSize.y) return;

    int r = clamp(_NormalBlurRadius, 0, 3);
    float sigma = max(_NormalBlurSigma, 1e-4);
    float invTwoSigma2 = 0.5 / (sigma * sigma);

    float3 accum = 0;
    float wsum = 0;

    for (int y = -r; y <= r; y++)
    {
        for (int x = -r; x <= r; x++)
        {
            int2 c = clamp(coord + int2(x, y), int2(0, 0), _SimSize - 1);
            float3 n = _ResultSrc.Load(int3(c, 0)).xyz; // 非パック法線
            float w = exp(- (x * x + y * y) * invTwoSigma2);
            accum += n * w;
            wsum += w;
        }
    }

    float3 nBlur = (wsum > 1e-6) ? accum / wsum : float3(0, 1, 0);
    float lenSq = dot(nBlur, nBlur);
    if (lenSq > 1e-8) nBlur = normalize(nBlur); else nBlur = float3(0, 1, 0);

    float height = _ResultSrc.Load(int3(coord, 0)).w; // 高さはそのまま
    _Result[coord] = float4(nBlur, height); // 非パック
}

[numthreads(THREADS, THREADS, 1)]
void Brush(uint3 id : SV_DispatchThreadID)
{
    int2 coord = int2(id.xy);
    if (coord.x >= _SimSize.x || coord.y >= _SimSize.y) return;
    float2 uv = (coord + 0.5) * _InvSimSize;

    float aspect = (_SimSize.y > 0) ? (_SimSize.x / (float)_SimSize.y) : 1.0;
    float2 delta = uv - _Brush.xy;
    delta.x *= aspect;

    float dist = length(delta);
    if (dist > _Brush.z) return;

    float t = saturate(1.0 - dist / _Brush.z);
    float fall = pow(t, max(_BrushFalloff, 0.0001));
    float add = _Brush.w * fall;

    _ForceTarget[coord] = _ForceTarget[coord] + add;
}

[numthreads(THREADS, THREADS, 1)]
void ClearForce(uint3 id : SV_DispatchThreadID)
{
    int2 coord = int2(id.xy);
    if (coord.x >= _SimSize.x || coord.y >= _SimSize.y) return;
    _ForceTarget[coord] = 0.0;
}

